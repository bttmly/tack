// Generated by CoffeeScript 1.7.1
(function() {
  var tackMaker,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof require === "function") {
    require("chai").should();
    tackMaker = require("../src/tack");
  } else {
    tackMaker = window.tackMaker;
  }

  describe("Maker function", function() {
    describe("Building from string (tagName)", function() {
      it("throws an error if passed an invalid tag name", function() {
        return (function() {
          return tackMaker("asdf");
        }).should["throw"]();
      });
      return it("works when passed a valid tag name", function() {
        var tag;
        tag = void 0;
        (function() {
          return tag = tackMaker("input");
        }).should.not["throw"]();
        tag.tagName.should.equal("input");
        tag.attributes.should.deep.equal({});
        tag["class"].should.deep.equal([]);
        return tag.children.should.deep.equal([]);
      });
    });
    return describe("Building from a DOM node", function() {
      var input, tag;
      input = document.createElement("input");
      input.id = "the-input";
      input.classList.add("class1");
      input.classList.add("class2");
      input.type = "text";
      input.name = "text-input";
      tag = tackMaker(input);
      return console.log(tag.toString());
    });
  });

  describe("Methods", function() {
    var ctor, proto, tag;
    tag = void 0;
    proto = void 0;
    ctor = void 0;
    beforeEach(function() {
      tag = tackMaker("div");
      proto = Object.getPrototypeOf(tag);
      return ctor = proto.constructor;
    });
    describe("attr", function() {
      it("Sets an attribute when called with two arguments, and returns self", function() {
        tag.attr("type", "text").should.equal(tag);
        return tag.attributes.type.should.equal("text");
      });
      return it("Returns an attribute value called with one argument", function() {
        tag.attr("type", "text");
        return tag.attr("type").should.equal("text");
      });
    });
    describe("id", function() {
      it("Sets the id attribute when called with an argument, and returns self", function() {
        tag.id("thing").should.equal(tag);
        return tag.attributes.id.should.equal("thing");
      });
      return it("Returns the id when called with no arguments", function() {
        tag.id("thing");
        return tag.id().should.equal("thing");
      });
    });
    describe("addClass", function() {
      return it("Adds a class if not already present, and returns self", function() {
        tag.addClass("someThing");
        tag.addClass("otherThing");
        tag.addClass("someThing").should.equal(tag);
        (__indexOf.call(tag["class"], "someThing") >= 0).should.be.ok;
        return tag["class"].length.should.equal(2);
      });
    });
    describe("removeClass", function() {
      return it("Adds a class if not already present, and returns self", function() {
        tag.addClass("someThing");
        tag.addClass("otherThing");
        tag.removeClass("someThing").should.equal(tag);
        (__indexOf.call(tag["class"], "someThing") >= 0).should.not.be.ok;
        return tag["class"].length.should.equal(1);
      });
    });
    describe("addChild", function() {
      return it("Adds child Stringers", function() {
        tag.addChild("div");
        tag.children.length.should.equal(1);
        return tag.children[0].should.be["instanceof"](ctor);
      });
    });
    return describe("render", function() {
      return it("Generates the correct HTML string", function() {
        tag.id("some-id");
        tag.addClass("some-class");
        tag.attr("name", "some-name");
        return tag.render().should.equal('<div class="some-class" id="some-id" name="some-name"></div>');
      });
    });
  });

  if (typeof mocha !== "undefined") {
    mocha.run();
  }

}).call(this);
